import os
import requests
import json
import time
import hashlib
import hmac
from urllib.parse import urlencode

# --- Configuration from GitHub Secrets ---
BINGX_API_KEY = os.environ['BINGX_API_KEY']
BINGX_SECRET_KEY = os.environ['BINGX_SECRET_KEY']
TRADER_UID = os.environ['TRADER_UID']
TELEGRAM_BOT_TOKEN = os.environ['TELEGRAM_BOT_TOKEN']
TELEGRAM_CHAT_ID = os.environ['TELEGRAM_CHAT_ID']

# File to store the previous state (within the GitHub runner's temporary file system)
STATE_FILE = 'previous_state.json'

# --- BingX API Functions ---
def generate_signature(secret_key, params):
    query = urlencode(params)
    return hmac.new(secret_key.encode('utf-8'), query.encode('utf-8'), hashlib.sha256).hexdigest()

def get_trader_positions(trader_uid):
    host = "https://open-api.bingx.com"
    endpoint = "/openApi/copyTrade/api/v1/trader/positions"
    params = {
        "copyTradeUserId": trader_uid,
        "recvWindow": 5000,
        "timestamp": int(time.time() * 1000)
    }
    params['signature'] = generate_signature(BINGX_SECRET_KEY, params)
    url = host + endpoint + "?" + urlencode(params)
    headers = {'X-BX-APIKEY': BINGX_API_KEY}
    
    try:
        response = requests.get(url, headers=headers)
        data = response.json()
        print("API Response:", json.dumps(data, indent=2)) # Helpful for debugging
        if 'data' in data:
            return {f"{p['symbol']}-{p['positionSide']}" for p in data['data']}
        else:
            print("Error fetching data or no data field:", data)
            return set()
    except Exception as e:
        print("Request failed:", e)
        return set()

# --- Notification Function ---
def send_telegram_alert(message):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    data = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": message
    }
    try:
        response = requests.post(url, data=data)
        print("Telegram response:", response.status_code)
    except Exception as e:
        print("Failed to send Telegram alert:", e)

# --- State Management ---
def load_previous_state():
    try:
        with open(STATE_FILE, 'r') as f:
            data = json.load(f)
            return set(data.get('positions', []))
    except FileNotFoundError:
        return set()

def save_current_state(positions):
    with open(STATE_FILE, 'w') as f:
        json.dump({'positions': list(positions)}, f)

# --- Main Execution ---
def main():
    print("Starting trader tracker check...")
    previous_positions = load_previous_state()
    current_positions = get_trader_positions(TRADER_UID)
    
    # Check for new trades (OPEN)
    new_trades = current_positions - previous_positions
    if new_trades:
        alert_msg = f"ðŸš¨ TRADE OPENED ðŸš¨\nTrader: {TRADER_UID}\nPosition: {', '.join(new_trades)}"
        print(alert_msg)
        send_telegram_alert(alert_msg)
    
    # Check for closed trades (CLOSE)
    closed_trades = previous_positions - current_positions
    if closed_trades:
        alert_msg = f"ðŸ”” TRADE CLOSED ðŸ””\nTrader: {TRADER_UID}\nPosition: {', '.join(closed_trades)}"
        print(alert_msg)
        send_telegram_alert(alert_msg)
    
    # Update the state if there were any changes
    if new_trades or closed_trades:
        save_current_state(current_positions)
    else:
        print("No changes detected.")

if __name__ == "__main__":
    main()
